# 푸드스팟 논리 아키텍처 설계서

## 1. 개요

### 1.1 설계 원칙

**핵심 원칙**
- **마이크로서비스 독립성**: 각 서비스는 독립적인 데이터베이스와 배포 가능한 구조
- **캐시 우선 전략**: Redis를 통한 성능 최적화와 서비스 간 직접 의존성 최소화
- **선택적 비동기**: 장시간 작업(AI 일정 생성)만 비동기 처리
- **API Gateway 중심**: 모든 외부 요청의 단일 진입점
- **이벤트 기반 통신**: 서비스 간 느슨한 결합을 통한 확장성 확보

**핵심 컴포넌트 정의**
- **API Gateway**: 클라이언트 요청의 단일 진입점, 인증/인가, 라우팅 담당
- **마이크로서비스**: Restaurant Search, Order Management, Value Assessment, Personalization, Admin Management
- **캐시 레이어**: Redis 기반 성능 최적화
- **이벤트 버스**: Apache Kafka 기반 비동기 통신
- **외부 연동**: 결제 게이트웨이, 지도 API, 푸시 알림 등

### 1.2 아키텍처 패턴 적용

선정된 클라우드 아키텍처 패턴을 다음과 같이 적용:

**Cache-Aside (최우선 적용)**
- 맛집 정보, 메뉴 데이터, AI 추천 결과 캐싱
- 데이터베이스 부하 80% 감소, 응답시간 500ms → 100ms 목표

**API Gateway**
- 모든 클라이언트 요청의 단일 진입점
- JWT 기반 인증/인가, 서비스별 라우팅

**Event-Driven Architecture**
- 실시간 대기시간 업데이트, 주문 상태 변경 알림
- 서비스 간 느슨한 결합 구현

**Circuit Breaker**
- 외부 API 연동 안정성 확보
- 결제 게이트웨이, 지도 API 연동 보호

## 2. 서비스 아키텍처

### 2.1 서비스별 책임

**Restaurant Search Service**
- **책임**: 식당 검색, 필터링, 개인화 추천, 실시간 대기시간 관리
- **데이터**: 식당 정보, 메뉴, 대기시간 데이터
- **캐시 전략**: 검색 결과 30분, 식당 정보 1시간 TTL
- **관련 유저스토리**: UFR-REST-010, UFR-REST-020, UFR-REST-030, UFR-REST-040, UFR-REST-050

**Order Management Service**
- **책임**: 메뉴 조회, 주문 처리, 결제, 주문 상태 추적
- **데이터**: 주문 정보, 결제 내역, 주문 상태
- **외부 연동**: 결제 게이트웨이 (Circuit Breaker 적용)
- **관련 유저스토리**: UFR-ORD-010, UFR-ORD-020, UFR-ORD-030, UFR-ORD-040, UFR-ORD-050

**Value Assessment Service**
- **책임**: 가성비 평가, 리뷰 관리, 평가 히스토리 분석
- **데이터**: 사용자 평가, 가성비 점수, 평가 통계
- **캐시 전략**: 개인별 가성비 기준 1시간 TTL
- **관련 유저스토리**: UFR-VAL-010, UFR-VAL-020, UFR-VAL-030, UFR-VAL-040

**Personalization Service**
- **책임**: 개인화 학습, 추천 생성, 만족도 예측, AI 모델 관리
- **데이터**: 사용자 선호도, 행동 패턴, AI 모델 파라미터
- **캐시 전략**: 추천 결과 15분, 개인 모델 6시간 TTL
- **관련 유저스토리**: UFR-PERS-010, UFR-PERS-020, UFR-PERS-030, UFR-PERS-040

**Admin Management Service**
- **책임**: 데이터 품질 관리, 시스템 모니터링, AI 모델 최적화
- **데이터**: 시스템 메트릭, 품질 지표, 관리 로그
- **관련 유저스토리**: AFR-ADM-010, AFR-ADM-020, NFR-ADM-030, AFR-ADM-040

### 2.2 서비스 간 통신 전략

**동기 통신 (API 호출)**
- 즉시 응답이 필요한 조회성 작업
- API Gateway → 각 마이크로서비스
- 캐시 우선 조회로 성능 최적화

**비동기 통신 (이벤트 기반)**
- 주문 생성 → 결제 처리 → 알림 발송
- 리뷰 작성 → AI 모델 업데이트
- 대기시간 업데이트 → 실시간 알림

**캐시 기반 데이터 공유**
- 서비스 간 직접 API 호출 최소화
- Redis를 통한 공통 데이터 접근
- 데이터 일관성과 성능의 균형

## 3. 주요 사용자 플로우

### 3.1 맛집 검색 및 주문 플로우

**플로우 단계**:
1. **검색 요청** → API Gateway → Restaurant Search Service
2. **캐시 조회** → Redis에서 검색 결과 확인
3. **개인화 추천** → Personalization Service에서 사용자별 추천
4. **식당 상세** → 캐시된 식당 정보 + 실시간 대기시간
5. **주문 생성** → Order Management Service
6. **결제 처리** → 외부 결제 게이트웨이 (Circuit Breaker 적용)
7. **주문 완료 이벤트** → 알림 발송, 추천 모델 업데이트

### 3.2 가성비 평가 및 학습 플로우

**플로우 단계**:
1. **식사 완료** → Value Assessment Service
2. **4요소 평가** → 가격/양/맛/서비스 점수 입력
3. **개인화 학습** → Personalization Service 이벤트 발행
4. **모델 업데이트** → AI 모델 재학습 트리거
5. **추천 개선** → 개인별 추천 가중치 조정

### 3.3 실시간 대기시간 관리 플로우

**플로우 단계**:
1. **대기시간 제공** → Restaurant Search Service
2. **실시간 업데이트** → 이벤트 버스로 변경사항 전파
3. **캐시 갱신** → Redis 실시간 대기시간 업데이트
4. **푸시 알림** → 관심 사용자에게 변경 알림

## 4. 데이터 흐름 및 캐싱 전략

### 4.1 캐시 계층 구조

**L1 캐시 (애플리케이션 레벨)**
- 자주 참조되는 정적 데이터 (메뉴, 카테고리)
- 메모리 기반, 10분 TTL

**L2 캐시 (Redis)**
- 동적 데이터와 계산 결과 캐싱
- 서비스 간 공유 캐시 공간
- TTL 기반 자동 만료

**캐시 무효화 전략**
- 데이터 변경 시 관련 캐시 즉시 삭제
- 이벤트 기반 캐시 갱신
- Cache-Aside 패턴으로 안정성 확보

### 4.2 데이터 플로우

**읽기 플로우**:
캐시 조회 → 캐시 히트 시 즉시 반환 → 캐시 미스 시 DB 조회 → 결과 캐싱 → 응답

**쓰기 플로우**:
DB 업데이트 → 관련 캐시 삭제 → 이벤트 발행 → 다른 서비스 캐시 갱신

**이벤트 플로우**:
이벤트 생성 → Kafka로 발행 → 관심 서비스에서 구독 → 비동기 처리

## 5. 확장성 및 성능 고려사항

### 5.1 수평 확장 전략

**서비스별 독립 스케일링**
- 트래픽 패턴에 따른 개별 서비스 확장
- Restaurant Search Service: 조회 중심, 읽기 복제본 활용
- Order Management Service: 쓰기 중심, 샤딩 고려
- Personalization Service: CPU 집약적, 전용 인스턴스 필요

**데이터베이스 분산 전략**
- 서비스별 독립 데이터베이스
- 읽기 복제본으로 조회 성능 향상
- 샤딩을 통한 쓰기 성능 분산

### 5.2 성능 최적화

**캐시 효율성**
- 캐시 히트율 90% 이상 목표
- TTL 최적화로 메모리 사용량 관리
- 캐시 워밍 전략으로 초기 성능 확보

**비동기 처리**
- AI 모델 학습 등 장시간 작업 비동기화
- 이벤트 큐를 통한 부하 분산
- 배치 처리로 효율성 향상

### 5.3 부하 분산

**API Gateway 레벨**
- 라운드 로빈, Weighted 라우팅
- 서비스별 헬스 체크 기반 라우팅
- 서킷 브레이커로 장애 전파 차단

**서비스 레벨**
- 로드 밸런서를 통한 인스턴스 분산
- 세션 스티키니스 최소화
- 무상태 서비스 설계

## 6. 보안 고려사항

### 6.1 인증 및 인가

**JWT 토큰 기반 인증**
- API Gateway에서 중앙화된 토큰 검증
- 서비스별 역할 기반 접근 제어 (RBAC)
- 토큰 갱신 및 만료 관리

**API 보안**
- HTTPS 통신 강제
- Rate Limiting으로 남용 방지
- CORS 정책 적용

### 6.2 데이터 보안

**개인정보 보호**
- 개인 식별 정보 암호화 저장
- 가명 처리를 통한 분석 데이터 보호
- 데이터 접근 로깅 및 모니터링

**결제 데이터 보안**
- PCI DSS 준수
- 결제 정보 외부 저장 금지
- 토큰화를 통한 카드 정보 보호

### 6.3 네트워크 보안

**서비스 간 통신**
- 내부 네트워크 VPC 격리
- 서비스 메시를 통한 mTLS
- 네트워크 레벨 방화벽 규칙

**외부 API 연동**
- API 키 관리 시스템
- 화이트리스트 기반 접근 제어
- 연동 트래픽 모니터링

## 7. 논리 아키텍처 다이어그램

논리 아키텍처의 전체 구조는 `logical-architecture.mmd` 파일에 Mermaid 형식으로 표현되어 있습니다.

**다이어그램 주요 구성요소**:
- 클라이언트 계층 (모바일/웹)
- API Gateway (단일 진입점)
- 마이크로서비스 계층 (5개 핵심 서비스)
- 캐시 계층 (Redis)
- 이벤트 버스 (Kafka)
- 데이터베이스 계층 (서비스별 독립 DB)
- 외부 서비스 연동

## 8. 구현 우선순위

### Phase 1 (Must Have - MVP)
- API Gateway 구축
- Restaurant Search Service (기본 검색)
- Order Management Service (핵심 주문 기능)
- Value Assessment Service (기본 평가)
- Redis 캐싱 적용

### Phase 2 (Should Have - 확장)
- Event-Driven Architecture 구축
- Personalization Service (AI 추천)
- 실시간 기능 (대기시간, 주문 상태)
- Circuit Breaker 패턴 적용

### Phase 3 (Could Have - 고도화)
- Admin Management Service
- 고급 분석 기능
- CQRS 패턴 적용
- 글로벌 확장 대비

---

**문서 정보**
- 작성일: 2025-09-25
- 작성자: 김태현(현빈) - Backend Developer
- 검토자: 이해민(민지) - Product Owner
- 승인일: 2025-09-25
- 버전: 1.0